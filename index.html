<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>慕课网:从基础到实战手把手带你掌握新版Webpack4.0 学习笔记</title>
    <style>
        body {
            background-color: #EEEFF5
        }

        * {
            font-family: '-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol';
        }

        .bold {
            font-weight: bold;
            width: 50px;
        }

        table {
            border-collapse: collapse;
            width: 1000px;
            margin: auto;
            background: #fff;
        }

        th,
        td {
            border: 1px solid #DFE2E5;
            border-collapse: collapse;
            padding: 5px;
        }

        tr:nth-child(odd) {
            background-color: #F8F8F8;
        }

        tr:hover {
            background-color: #e4ebf0;
        }
    </style>
</head>

<body>
    <div id='root'></div>
    <h2 style="width:100%;margin:20px auto;text-align: center">慕课网:从基础到实战手把手带你掌握新版Webpack4.0 学习笔记</h2>
    <table>
        <tr>
            <th style="width:50px">序号</th>
            <th>标题</th>
            <th>内容</th>
            <th>备注</th>
            <th style="width:50px">章节</th>
        </tr>
        <tr>
            <td>1</td>
            <td>webpack是一个模块打包工具,自身只能翻译import这样的语句</td>
            <td>除了能识别js module(import)的加载方式,commonjs(require,module.exports),amd,cmd的加载方式都能识别</td>
            <td></td>
            <td>2-2</td>
        </tr>
        <tr>
            <td>2</td>
            <td>建议项目内安装webpack</td>
            <td>因为有的项目是webpack3,有的是4,全局只有一个版本,会出问题</td>
            <td></td>
            <td>2-3</td>
        </tr>
        <tr>
            <td>3</td>
            <td>npx</td>
            <td>执行当前目录下的node包中的命令,比如npx webpack,就是执行当前目录下的webpack,否则直接写webpack就会全局搜索了,搜不到就报错了</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>4</td>
            <td>npm init -y</td>
            <td>自动生成默认配置,不需要询问了</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>5</td>
            <td>npm info webpack</td>
            <td>可以查看webpack的所有信息,包括版本</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>6</td>
            <td>webpack默认配置文件名字叫webpack.config.js</td>
            <td>使用npx webpack --config abc.js可以修改默认webpack配置文件名字</td>
            <td></td>
            <td>2-4</td>
        </tr>
        <tr>
            <td>7</td>
            <td>npm script</td>
            <td>在package.json文件中的script中写入命令: "bundle": "webpack" 然后npm run bundle就可以代替npx webpack了</td>
            <td>并且是先查找项目node_modules的依赖,找不到才查找全局,类似于npx</td>
            <td></td>
        </tr>
        <tr>
            <td>8</td>
            <td>运行webpack的三种方式</td>
            <td>
                1.全局 webpack
                2.npx webpack
                3.npm run
            </td>
            <td>并且是先查找项目node_modules的依赖,找不到才查找全局,类似于npx</td>
            <td></td>
        </tr>
        <tr>
            <td>9</td>
            <td>webpack cli</td>
            <td>使得我们可以在命令行中使用webpack命令</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>10</td>
            <td>entry: "./src/index.js"</td>
            <td>这是个简写,复杂写法为
                entry: {
                main: './src/index.js'
                },
            </td>
            <td></td>
            <td>2-5</td>
        </tr>
        <tr>
            <td>11</td>
            <td>const a=require('img.jpg')</td>
            <td>console.log这个a,输出的就是文件名(webpack file-loader)</td>
            <td>
                file-loader原理:webpack打包时不知道如何打包图片,就去modules里面找,
                找到test的正则,按照文件扩展名匹配,匹配到jpg使用file-loader处理,就开始打包,
                首先把他图片拷贝到要输出的文件夹,并且改名,然后把图片的名字返回给require的变量
            </td>
            <td>3-1</td>
        </tr>
        <tr>
            <td>12</td>
            <td>loader是什么</td>
            <td>就是对于特定文件打包处理的方案</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>13</td>
            <td>webpack默认只能处理.js结尾的文件</td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>14</td>
            <td>使用 Loader 打包静态资源（图片篇）</td>
            <td>笔记见webpack.config文件(lesson:3-2)</td>
            <td></td>
            <td>3-2</td>
        </tr>
        <tr>
            <td>15</td>
            <td>3-3 使用 Loader 打包静态资源（样式篇 - 上）</td>
            <td>笔记见webpack.config,postcss.config文件(lesson:3-3)</td>
            <td></td>
            <td>3-3</td>
        </tr>
        <tr>
            <td>16</td>
            <td>3-4 使用 Loader 打包静态资源（样式篇 - 下）</td>
            <td>笔记见webpack.config文件(lesson:3-4)</td>
            <td>官网->DOCUMENTATION->Asset Management</td>
            <td>3-4</td>
        </tr>
        <tr>
            <td>16</td>
            <td>3-5 使用 plugins 让打包更便捷</td>
            <td></td>
            <td></td>
            <td>3-5 源码2-5</td>
        </tr>
        <tr>
            <td>16</td>
            <td>3-6 Entry 与 Output 的基础配置</td>
            <td></td>
            <td>作业:https://webpack.js.org/configuration/output<br />
                https://webpack.docschina.org/guides/output-management/
            </td>
            <td>源码2-6</td>
        </tr>
        <tr>
            <td>17</td>
            <td>3-7 SourceMap 的配置</td>
            <td></td>
            <td></td>
            <td>源码2-7</td>
        </tr>
        <tr>
            <td>18</td>
            <td>3-8 使用 WebpackDevServer 提升开发效率</td>
            <td>
                package.json文件添加
                "scripts": {
                "watch": "webpack --watch"
                }
            </td>
            <td>webpack --watch用来监控src文件夹内的改变,有改变会自动打包一次</td>
            <td>视频3-8 源码2-8 其他见webpack.config.js lesson:3-8</td>
        </tr>
        <tr>
            <td>19</td>
            <td>3-9 Hot Module Replacement 热模块更新（1）</td>
            <td></td>
            <td></td>
            <td>视频3-9 源码2-9</td>
        </tr>
        <tr>
            <td>20</td>
            <td>3-10 Hot Module Replacement 热模块更新（2）</td>
            <td>
                <pre>
                    开启热更新后默认只能热更新css,如果想热更新js代码,
                    还要在头文件index.js
                    中加入以下代码,accept表示要监控的变化的文件,
                    后面接一个变化后的回调函数(css-loader已经实现,所以可以默认热更新css)
                    ,react,vue-loader也都已经实现
                    if(module.hot){
                        module.hot.accept('./test',()=>{
                            console.log("hot")
                        })
                    }
                    </pre>
            </td>
            <td></td>
            <td>视频3-10 源码2-9</td>
        </tr>
        <tr>
            <td>21</td>
            <td>3-11 使用 Babel 处理 ES6 语法（1）</td>
            <td></td>
            <td></td>
            <td>lesson:3-11</td>
        </tr>
        <tr>
            <td>22</td>
            <td>3-12 使用 Babel 处理 ES6 语法（2）</td>
            <td></td>
            <td></td>
            <td>lesson:3-12</td>
        </tr>
        <tr>
            <td>23</td>
            <td>3-13 Webpack 实现对React框架代码的打包</td>
            <td></td>
            <td><a href="https://www.babeljs.cn/docs/babel-preset-react" target="_blank">配置方法</a></td>
            <td>lesson:3-13</td>
        </tr>
        <tr>
            <td>24</td>
            <td>4-1 Tree Shaking 概念详解</td>
            <td>
                Tree Shaking翻译成中文叫摇树,把一棵树上没用的东西都摇掉<br />
                就是打包时只打进引入的方法或变量,没有引入的不打包,以减小打包后的体积<br>
                比如一个js文件中有add,minus两个方法,只引入了add,那么打包也会只有add
            </td>
            <td>Tree Shaking 只支持 ES Module(import方式引入)</td>
            <td>lesson:4-1 源码3-1</td>
        </tr>
        <tr>
            <td>25</td>
            <td>4-2 Develoment 和 Production 模式的区分打包</td>
            <td>
                Develoment:不压缩<br>
                Production:压缩
            </td>
            <td>代码见1.package.js里面script下的"dev","bulid"<br>
                2.build文件夹下webpack.dev.js,webpack.prod.js<br>
                3.build文件夹下webpack.common.js
            </td>
            <td>lesson:4-2 源码3-2</td>
        </tr>
        <tr>
            <td>26</td>
            <td>4-3 Webpack 和 Code Splitting（1）</td>
            <td>1.业务代码中引入过大库(lodash)会导致打包后的main.js过大,加载时间过长<br>
                2.而lodash一般不会修改,但是业务代码会经常修改,打包一次,用户的缓存没了,又要重新加载,白白的重新加载了一次lodash<br>
                解决方法,可以利用多入口,生成多个文件,html模板会依次引入多个文件,先引入库(将lodash添加到全局变量),然后后面的业务代码就可以运行了
                <img src="./img/1.png">
            </td>
            <td>1.package.js文件下"dev-build"<br>
            </td>
            <td>lesson:4-2 源码3-3</td>
        </tr>
        <tr>
            <td>27</td>
            <td>4-4 Webpack 和 Code Splitting（2）</td>
            <td></td>
            <td>笔记:webpack.common.js文件,lesson:4-4<br>
            </td>
            <td>lesson:4-4 源码3-3</td>
        </tr>
        <tr>
            <td>28</td>
            <td>4-5 SplitChunksPlugin 配置参数详解（1）</td>
            <td></td>
            <td><br>
            </td>
            <td>lesson:4-5 源码3-4</td>
        </tr>
        <tr>
            <td>29</td>
            <td>4-6 SplitChunksPlugin 配置参数详解（2）</td>
            <td></td>
            <td>https://webpack.js.org/plugins/split-chunks-plugin/<br>
            </td>
            <td>lesson:4-6 源码3-5</td>
        </tr>
        <tr>
            <td>30</td>
            <td>4-7 Lazy Loading 懒加载，Chunk 是什么？</td>
            <td>Chunk:webpack打包生成了几个js文件,就是几个Chunk</td>
            <td><img src="./img/2.png"><br>
            </td>
            <td>lesson:4-7</td>
        </tr>
    </table>
</body>

</html>