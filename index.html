<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>慕课网:从基础到实战手把手带你掌握新版Webpack4.0 学习笔记</title>
    <style>
        body {
            background-color: #EEEFF5
        }

        * {
            font-family: '-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol';
        }

        .bold {
            font-weight: bold;
            width: 50px;
        }

        table {
            border-collapse: collapse;
            width: 1000px;
            margin: auto;
            background: #fff;
        }

        th,
        td {
            border: 1px solid #DFE2E5;
            border-collapse: collapse;
            padding: 5px;
        }

        tr:nth-child(odd) {
            background-color: #F8F8F8;
        }

        tr:hover {
            background-color: #e4ebf0;
        }
    </style>
</head>

<body>
    <div id='root'></div>
    <h2 style="width:100%;margin:20px auto;text-align: center">慕课网:从基础到实战手把手带你掌握新版Webpack4.0 学习笔记</h2>
    <table>
        <tr>
            <th style="width:50px">序号</th>
            <th>标题</th>
            <th>内容</th>
            <th>备注</th>
            <th style="width:50px">章节</th>
        </tr>
        <tr>
            <td>1</td>
            <td>webpack是一个模块打包工具,自身只能翻译import这样的语句</td>
            <td>除了能识别js module(import)的加载方式,commonjs(require,module.exports),amd,cmd的加载方式都能识别</td>
            <td></td>
            <td>2-2</td>
        </tr>
        <tr>
            <td>2</td>
            <td>建议项目内安装webpack</td>
            <td>因为有的项目是webpack3,有的是4,全局只有一个版本,会出问题</td>
            <td></td>
            <td>2-3</td>
        </tr>
        <tr>
            <td>3</td>
            <td>npx</td>
            <td>执行当前目录下的node包中的命令,比如npx webpack,就是执行当前目录下的webpack,否则直接写webpack就会全局搜索了,搜不到就报错了</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>4</td>
            <td>npm init -y</td>
            <td>自动生成默认配置,不需要询问了</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>5</td>
            <td>npm info webpack</td>
            <td>可以查看webpack的所有信息,包括版本</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>6</td>
            <td>webpack默认配置文件名字叫webpack.config.js</td>
            <td>使用npx webpack --config abc.js可以修改默认webpack配置文件名字</td>
            <td></td>
            <td>2-4</td>
        </tr>
        <tr>
            <td>7</td>
            <td>npm script</td>
            <td>在package.json文件中的script中写入命令: "bundle": "webpack" 然后npm run bundle就可以代替npx webpack了</td>
            <td>并且是先查找项目node_modules的依赖,找不到才查找全局,类似于npx</td>
            <td></td>
        </tr>
        <tr>
            <td>8</td>
            <td>运行webpack的三种方式</td>
            <td>
                1.全局 webpack
                2.npx webpack
                3.npm run
            </td>
            <td>并且是先查找项目node_modules的依赖,找不到才查找全局,类似于npx</td>
            <td></td>
        </tr>
        <tr>
            <td>9</td>
            <td>webpack cli</td>
            <td>使得我们可以在命令行中使用webpack命令</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>10</td>
            <td>entry: "./src/index.js"</td>
            <td>这是个简写,复杂写法为
                entry: {
                main: './src/index.js'
                },
            </td>
            <td></td>
            <td>2-5</td>
        </tr>
        <tr>
            <td>11</td>
            <td>const a=require('img.jpg')</td>
            <td>console.log这个a,输出的就是文件名(webpack file-loader)</td>
            <td>
                file-loader原理:webpack打包时不知道如何打包图片,就去modules里面找,
                找到test的正则,按照文件扩展名匹配,匹配到jpg使用file-loader处理,就开始打包,
                首先把他图片拷贝到要输出的文件夹,并且改名,然后把图片的名字返回给require的变量
            </td>
            <td>3-1</td>
        </tr>
        <tr>
            <td>12</td>
            <td>loader是什么</td>
            <td>就是对于特定文件打包处理的方案</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>13</td>
            <td>webpack默认只能处理.js结尾的文件</td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>14</td>
            <td>使用 Loader 打包静态资源（图片篇）</td>
            <td>笔记见webpack.config文件(lesson:3-2)</td>
            <td></td>
            <td>3-2</td>
        </tr>
        <tr>
            <td>15</td>
            <td>3-3 使用 Loader 打包静态资源（样式篇 - 上）</td>
            <td>笔记见webpack.config,postcss.config文件(lesson:3-3)</td>
            <td></td>
            <td>3-3</td>
        </tr>
        <tr>
            <td>16</td>
            <td>3-4 使用 Loader 打包静态资源（样式篇 - 下）</td>
            <td>笔记见webpack.config文件(lesson:3-4)</td>
            <td>官网->DOCUMENTATION->Asset Management</td>
            <td>3-4</td>
        </tr>
        <tr>
            <td>16</td>
            <td>3-5 使用 plugins 让打包更便捷</td>
            <td></td>
            <td></td>
            <td>3-5 源码2-5</td>
        </tr>
        <tr>
            <td>16</td>
            <td>3-6 Entry 与 Output 的基础配置</td>
            <td></td>
            <td>作业:https://webpack.js.org/configuration/output<br />
                https://webpack.docschina.org/guides/output-management/
            </td>
            <td>源码2-6</td>
        </tr>
        <tr>
            <td>17</td>
            <td>3-7 SourceMap 的配置</td>
            <td></td>
            <td></td>
            <td>源码2-7</td>
        </tr>
        <tr>
            <td>18</td>
            <td>3-8 使用 WebpackDevServer 提升开发效率</td>
            <td>
                package.json文件添加
                "scripts": {
                "watch": "webpack --watch"
                }
            </td>
            <td>webpack --watch用来监控src文件夹内的改变,有改变会自动打包一次</td>
            <td>视频3-8 源码2-8 其他见webpack.config.js lesson:3-8</td>
        </tr>
        <tr>
            <td>19</td>
            <td>3-9 Hot Module Replacement 热模块更新（1）</td>
            <td></td>
            <td></td>
            <td>视频3-9 源码2-9</td>
        </tr>
        <tr>
            <td>20</td>
            <td>3-10 Hot Module Replacement 热模块更新（2）</td>
            <td>
                <pre>
                    开启热更新后默认只能热更新css,如果想热更新js代码,
                    还要在头文件index.js
                    中加入以下代码,accept表示要监控的变化的文件,
                    后面接一个变化后的回调函数(css-loader已经实现,所以可以默认热更新css)
                    ,react,vue-loader也都已经实现
                    if(module.hot){
                        module.hot.accept('./test',()=>{
                            console.log("hot")
                        })
                    }
                    </pre>
            </td>
            <td></td>
            <td>视频3-10 源码2-9</td>
        </tr>
        <tr>
            <td>21</td>
            <td>3-11 使用 Babel 处理 ES6 语法（1）</td>
            <td></td>
            <td></td>
            <td>lesson:3-11</td>
        </tr>
        <tr>
            <td>22</td>
            <td>3-12 使用 Babel 处理 ES6 语法（2）</td>
            <td></td>
            <td></td>
            <td>lesson:3-12</td>
        </tr>
        <tr>
            <td>23</td>
            <td>3-13 Webpack 实现对React框架代码的打包</td>
            <td></td>
            <td><a href="https://www.babeljs.cn/docs/babel-preset-react" target="_blank">配置方法</a></td>
            <td>lesson:3-13</td>
        </tr>
        <tr>
            <td>24</td>
            <td>4-1 Tree Shaking 概念详解</td>
            <td>
                Tree Shaking翻译成中文叫摇树,把一棵树上没用的东西都摇掉<br />
                就是打包时只打进引入的方法或变量,没有引入的不打包,以减小打包后的体积<br>
                比如一个js文件中有add,minus两个方法,只引入了add,那么打包也会只有add
            </td>
            <td>Tree Shaking 只支持 ES Module(import方式引入)</td>
            <td>lesson:4-1 源码3-1</td>
        </tr>
        <tr>
            <td>25</td>
            <td>4-2 Develoment 和 Production 模式的区分打包</td>
            <td>
                Develoment:不压缩<br>
                Production:压缩
            </td>
            <td>代码见1.package.js里面script下的"dev","bulid"<br>
                2.build文件夹下webpack.dev.js,webpack.prod.js<br>
                3.build文件夹下webpack.common.js
            </td>
            <td>lesson:4-2 源码3-2</td>
        </tr>
        <tr>
            <td>26</td>
            <td>4-3 Webpack 和 Code Splitting（1）</td>
            <td>1.业务代码中引入过大库(lodash)会导致打包后的main.js过大,加载时间过长<br>
                2.而lodash一般不会修改,但是业务代码会经常修改,打包一次,用户的缓存没了,又要重新加载,白白的重新加载了一次lodash<br>
                解决方法,可以利用多入口,生成多个文件,html模板会依次引入多个文件,先引入库(将lodash添加到全局变量),然后后面的业务代码就可以运行了
                <img src="./img/1.png">
            </td>
            <td>1.package.js文件下"dev-build"<br>
            </td>
            <td>lesson:4-2 源码3-3</td>
        </tr>
        <tr>
            <td>27</td>
            <td>4-4 Webpack 和 Code Splitting（2）</td>
            <td></td>
            <td>笔记:webpack.common.js文件,lesson:4-4<br>
            </td>
            <td>lesson:4-4 源码3-3</td>
        </tr>
        <tr>
            <td>28</td>
            <td>4-5 SplitChunksPlugin 配置参数详解（1）</td>
            <td></td>
            <td><br>
            </td>
            <td>lesson:4-5 源码3-4</td>
        </tr>
        <tr>
            <td>29</td>
            <td>4-6 SplitChunksPlugin 配置参数详解（2）</td>
            <td></td>
            <td>https://webpack.js.org/plugins/split-chunks-plugin/<br>
            </td>
            <td>lesson:4-6 源码3-5</td>
        </tr>
        <tr>
            <td>30</td>
            <td>4-7 Lazy Loading 懒加载，Chunk 是什么？</td>
            <td>Chunk:webpack打包生成了几个js文件,就是几个Chunk</td>
            <td><img src="./img/2.png"><br>
            </td>
            <td>lesson:4-7</td>
        </tr>
        <tr>
            <td>31</td>
            <td>4-8 打包分析，Preloading, Prefetching</td>
            <td>
                1.打包分析:对打包后生成的代码进行分析:https://github.com/webpack/analyse,https://webpack.js.org/guides/code-splitting/#bundle-analysis,生成stats.json用于分析,一般使用webpack-bundle-analyzer居多<br>
                2.chrome浏览器ctrl+shift+p可以调出显示面板,想写出高性能页面,就要提高代码利用率,chrome:调出显示面板输入:show coverage然后进行录制<br>
                3.Preload,Prefetch场景:首页显示页面,右上角有个登录按钮,如果登录界面是异步加载,那么点击登录时才加载会影响用户体验,如果在首页加载完毕后再偷偷加载好登录弹窗,就不影响体验了,这就是Preloading<br>
                4.Preload,Prefetch区别:类似同步和异步,Prefetch等页面主要内容(核心业务代码)加载完成后才去加载(同步),Preload和主页面一同去加载(异步)
                前端性能优化,缓存对于页面性能的提升很有限,要专注于code coverage上,才能真正提升用户体验<br>
                备注:代码率用率:页面上有click按钮,点击时才执行某一事件,那么这段代码就会降低页面利用率,因为页面加载时不需要这段代码,这段可以异步加载,点击时再引入这段逻辑,可以有效降低当前页面打包后的js文件大小,提升加载速度,减少用户加载页面的等待时间
            </td>
            <td><br>
            </td>
            <td>lesson:4-8 源码3-6</td>
        </tr>
        <tr>
            <td>32</td>
            <td>4-9 CSS 文件的代码分割</td>
            <td>
                1.安装:https://webpack.js.org/plugins/mini-css-extract-plugin/ 该插件不支持热更新,所有只有线上模式才会用<br>
                2.enforce:true,会略其他参数,不管了
            </td>
            <td>有时明明打包完毕,缺看不到打包完生成的文件,就去检查一下是否开启了tree-shaking</td>
            <td>lesson:4-9</td>
        </tr>
        <tr>
            <td>33</td>
            <td>4-10 Webpack 与浏览器缓存( Caching )</td>
            <td>
                打包时让文件根据内容而变化hash,文件没变化hash就不会变,生成的文件名就不会变,用户就可以使用之前的缓存,只加载变化的文件<br>

            </td>
            <td></td>
            <td>lesson:4-10</td>
        </tr>
        <tr>
            <td>34</td>
            <td>4-11 Shimming 的作用</td>
            <td>
                1.Shimming:垫片,babel-polyfill就是Shimming的一种,用于处理浏览器兼容性的
                2.import这种属于化模块开发,模块与模块之间不会耦合,比如a模块加载了jq,
                又加载了b模块,而b模块直接使用$会报错,因为a模块中的jq,b模块访问不到,他们之间的变量是隔离的
                3.this默认指向模块自身
            </td>
            <td></td>
            <td>lesson:4-11</td>
        </tr>
        <tr>
            <td>35</td>
            <td>4-12 环境变量的使用方法</td>
            <td></td>
            <td></td>
            <td>lesson:4-12</td>
        </tr>
        <tr>
            <td>36</td>
            <td>5-1 Library 的打包</td>
            <td></td>
            <td></td>
            <td>lesson:5-1 代码:5-1</td>
        </tr>
        <tr>
            <td>37</td>
            <td>5-2 PWA 的打包配置</td>
            <td></td>
            <td></td>
            <td>lesson:5-2</td>
        </tr>
        <tr>
            <td>38</td>
            <td>5-3 TypeScript 的打包配置</td>
            <td></td>
            <td></td>
            <td>lesson:5-3</td>
        </tr>
        <tr>
            <td>39</td>
            <td>5-4 使用 WebpackDevServer 实现请求转发</td>
            <td></td>
            <td></td>
            <td>lesson:5-4 源码4-4</td>
        </tr>
        <tr>
            <td>40</td>
            <td>5-5 WebpackDevServer 解决单页面应用路由问题</td>
            <td></td>
            <td></td>
            <td>lesson:5-5 源码4-5</td>
        </tr>
        <tr>
            <td>40</td>
            <td>5-6,5-7 EsLint 在 Webpack 中的配置</td>
            <td></td>
            <td></td>
            <td>lesson:5-6,lesson:5-7 代码4-6</td>
        </tr>
        <tr>
            <td>41</td>
            <td>5-8 webpack 性能优化(1) </td>
            <td>
                1.升级node,npm,webpack等等<br>
                2.在尽可能少的模块上应用loader<br>
                3.Plugin尽可能精简并确保可靠(使用官方推荐插件,官网上的插件)
            </td>
            <td></td>
            <td>lesson:5-8 代码4-7</td>
        </tr>
        <tr>
            <td>42</td>
            <td>5-9 webpack 性能优化(2) </td>
            <td>
            </td>
            <td></td>
            <td>lesson:5-9 代码4-8</td>
        </tr>
        <tr>
            <td>43</td>
            <td>5-10,5-11 webpack 性能优化(3,4) </td>
            <td>
            </td>
            <td></td>
            <td>lesson:5-10,lesson:5-11 代码4-9</td>
        </tr>
        <tr>
            <td>44</td>
            <td>5-12 webpack性能优化(5) </td>
            <td>1.控制包文件大小(tree-shaking)<br>
                2.webpack使用的node是单线程的语言,可以使用thread-loader,happypack等多进程打包工具<br>
                3.合理使用sourceMap<br>
                4.结合stats分析打包结果<br>
                5.开发环境内存编译<br>
                6.开发环境无用插件剔除<br>
                7.熟悉文档,熟练运用
            </td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>45</td>
            <td>5-13 多页面打包配置 </td>
            <td>
            </td>
            <td></td>
            <td>lesson:5-13 代码4-11</td>
        </tr>
        <tr>
            <td>46</td>
            <td>6-1,6-2 如何编写一个 Loader</td>
            <td>
            </td>
            <td></td>
            <td>lesson:6-1 源码5-1</td>
        </tr>
        <tr>
            <td>47</td>
            <td>6-3 如何编写一个 Plugin</td>
            <td>
                loader:帮助处理模块<br>
                plugin:包含一个webpack的生命周期,可以在某一时刻做某件事
            </td>
            <td></td>
            <td>lesson:6-3 源码5-2</td>
        </tr>
        <tr>
            <td>48</td>
            <td>6-4,6-5 Bundler 源码编写（模块分析 1,2）手写webpack</td>
            <td>
            </td>
            <td></td>
            <td>lesson:6-4 源码5-3</td>
        </tr>
        <tr>
            <td>49</td>
            <td>6-6 Bundler 源码编写（ Dependencies Graph ）</td>
            <td>
            </td>
            <td></td>
            <td>lesson:6- 源码5-</td>
        </tr>
    </table>
</body>

</html>